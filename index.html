<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Picture Puzzle Game</title>
    <style>
        /* Import a fun, game-appropriate font */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            overflow: auto; /* Allow scrolling if content overflows */
        }

        .game-container {
            background-color: #2d3748;
            border: 5px solid #4f46e5; /* Indigo border */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            text-align: center;
            max-width: 95%;
            width: 450px; /* Max width for desktop */
            margin-bottom: 20px;
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #6366f1; /* Brighter indigo */
            text-shadow: 2px 2px #000;
        }

        .puzzle-board {
            display: grid;
            /* Grid will be dynamically set by JS (e.g., grid-template-columns: repeat(3, 1fr);) */
            gap: 5px; /* Gap between puzzle pieces */
            width: 100%; /* Puzzle board takes full width of container */
            padding-bottom: 100%; /* Maintain 1:1 aspect ratio for the board */
            position: relative; /* For absolute positioning of tiles */
            background-color: #4a5568; /* Background for the board */
            border-radius: 8px;
            overflow: hidden;
            margin: 0 auto 20px auto;
        }

        .puzzle-tile {
            position: absolute; /* Position tiles absolutely within the grid */
            width: calc(100% / var(--grid-size)); /* Calculated width */
            height: calc(100% / var(--grid-size)); /* Calculated height */
            background-image: url('https://placehold.co/300x300/000000/FFFFFF?text=PUZZLE'); /* Placeholder image */
            background-size: var(--grid-size-px) var(--grid-size-px); /* Full image size */
            border: 2px solid #333; /* Border for tiles */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            cursor: pointer;
            transition: transform 0.3s ease-in-out; /* Smooth sliding animation */
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 2rem; /* For numbers if no image */
            font-weight: bold;
            text-shadow: 1px 1px #000;
        }

        .blank-tile {
            background-color: #333; /* Darker background for the blank space */
            background-image: none; /* No image for the blank tile */
            cursor: default;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
        }

        .game-button {
            background-color: #10b981; /* Green for start/restart */
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
        }

        .game-button:hover {
            background-color: #059669; /* Darker green on hover */
            transform: translateY(-2px);
        }

        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #message {
            margin-top: 20px;
            font-size: 1.1rem;
            color: #a78bfa; /* Light purple for messages */
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }
            .game-container {
                padding: 15px;
            }
            .puzzle-tile {
                font-size: 1.5rem;
            }
            .game-button {
                font-size: 0.8rem;
                padding: 8px 15px;
            }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1>Picture Puzzle!</h1>
        <div id="puzzle-board">
            <!-- Puzzle tiles will be generated here by JavaScript -->
        </div>

        <div class="controls">
            <button id="shuffleButton" class="game-button">Shuffle</button>
            <button id="resetButton" class="game-button">Reset</button>
        </div>
        <p id="message">Arrange the pieces to complete the picture!</p>
    </div>

    <script>
        const puzzleBoard = document.getElementById('puzzle-board');
        const shuffleButton = document.getElementById('shuffleButton');
        const resetButton = document.getElementById('resetButton');
        const messageDisplay = document.getElementById('message');

        const gridSize = 3; // For a 3x3 puzzle
        const totalTiles = gridSize * gridSize;
        const blankTileIndex = totalTiles - 1; // The last tile will be blank

        // Placeholder image URL - you can replace this with your own image!
        // Make sure your image is square for best results (e.g., 300x300 pixels)
        const imageUrl = 'https://placehold.co/300x300/000000/FFFFFF?text=PUZZLE';

        let tiles = []; // Array to hold the DOM tile elements
        let currentOrder = []; // Array to hold the current order of tile indices (0 to 8)
        let tileWidth, tileHeight; // Dimensions of each tile

        // --- Game Initialization ---
        function initializePuzzle() {
            puzzleBoard.innerHTML = ''; // Clear any existing tiles
            tiles = [];
            currentOrder = [];

            // Set CSS variables for grid size for responsive tiles
            puzzleBoard.style.setProperty('--grid-size', gridSize);

            // Create tiles
            for (let i = 0; i < totalTiles; i++) {
                const tile = document.createElement('div');
                tile.classList.add('puzzle-tile');
                tile.dataset.originalIndex = i; // Store original index for win check

                // Calculate background position for each tile
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                // Background position percentages: (col / (gridSize - 1)) * 100%
                // For a 3x3 grid, positions are 0%, 50%, 100%
                const bgPosX = (col / (gridSize - 1)) * 100;
                const bgPosY = (row / (gridSize - 1)) * 100;

                tile.style.backgroundImage = `url('${imageUrl}')`;
                tile.style.backgroundPosition = `${bgPosX}% ${bgPosY}%`;

                // If it's the blank tile, add a specific class and remove image
                if (i === blankTileIndex) {
                    tile.classList.add('blank-tile');
                    tile.style.backgroundImage = 'none'; // Ensure no image for blank
                } else {
                    // For debugging or if no image, display numbers
                    // tile.textContent = i + 1;
                }

                tile.addEventListener('click', handleTileClick);
                tiles.push(tile);
                currentOrder.push(i); // Initial order (0, 1, 2, ..., 8)
            }

            // Call renderPuzzle after a small delay to ensure layout is stable
            // This is the key fix for the layout issue on some mobile browsers
            setTimeout(() => {
                const boardSize = puzzleBoard.offsetWidth;
                puzzleBoard.style.setProperty('--grid-size-px', `${boardSize}px`);
                renderPuzzle(); // Render the initial (solved) puzzle
                messageDisplay.textContent = 'Click Shuffle to start!';
            }, 100); // Small delay of 100ms
        }

        // --- Render Puzzle ---
        // Positions tiles based on their currentOrder
        function renderPuzzle() {
            puzzleBoard.innerHTML = ''; // Clear existing tiles
            const boardWidth = puzzleBoard.offsetWidth;
            tileWidth = boardWidth / gridSize;
            tileHeight = boardWidth / gridSize; // Assuming square tiles

            // Update --grid-size-px CSS variable before rendering tiles
            puzzleBoard.style.setProperty('--grid-size-px', `${boardWidth}px`);


            currentOrder.forEach((originalIdx, currentPos) => {
                const tile = tiles[originalIdx]; // Get the actual tile element
                const targetRow = Math.floor(currentPos / gridSize);
                const targetCol = currentPos % gridSize;

                tile.style.transform = `translate(${targetCol * tileWidth}px, ${targetRow * tileHeight}px)`;
                puzzleBoard.appendChild(tile);
            });
        }

        // --- Shuffle Puzzle ---
        function shufflePuzzle() {
            // Simple shuffle: Fisher-Yates algorithm
            for (let i = currentOrder.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentOrder[i], currentOrder[j]] = [currentOrder[j], currentOrder[i]];
            }

            // Ensure the blank tile is at its correct position in the shuffled array for movement logic
            // Find the current position of the blank tile (original index blankTileIndex)
            const blankOriginalPos = currentOrder.indexOf(blankTileIndex);
            // Move it to the last position in the currentOrder array for now
            currentOrder.splice(blankOriginalPos, 1);
            currentOrder.push(blankTileIndex);

            // Re-render the shuffled puzzle
            renderPuzzle();
            messageDisplay.textContent = 'Puzzle shuffled! Solve it!';
        }


        // --- Handle Tile Click ---
        function handleTileClick(event) {
            const clickedTile = event.target;
            const clickedOriginalIndex = parseInt(clickedTile.dataset.originalIndex);

            // Find the current position (index in currentOrder array) of the clicked tile
            const clickedCurrentPos = currentOrder.indexOf(clickedOriginalIndex);
            // Find the current position of the blank tile
            const blankCurrentPos = currentOrder.indexOf(blankTileIndex);

            // Check if the clicked tile is adjacent to the blank tile
            const isAdjacent = (
                (Math.abs(clickedCurrentPos - blankCurrentPos) === 1 && // Same row, adjacent column
                 Math.floor(clickedCurrentPos / gridSize) === Math.floor(blankCurrentPos / gridSize)) ||
                (Math.abs(clickedCurrentPos - blankCurrentPos) === gridSize) // Same column, adjacent row
            );

            if (isAdjacent) {
                // Swap the clicked tile with the blank tile in the currentOrder array
                [currentOrder[clickedCurrentPos], currentOrder[blankCurrentPos]] =
                [currentOrder[blankCurrentPos], currentOrder[clickedCurrentPos]];

                renderPuzzle(); // Re-render the puzzle after swap
                checkWin(); // Check if puzzle is solved
            }
        }

        // --- Check for Win Condition ---
        function checkWin() {
            // Check if currentOrder matches the solved order (0, 1, 2, ..., 8)
            const solved = currentOrder.every((value, index) => value === index);
            if (solved) {
                messageDisplay.textContent = 'Congratulations! You solved the puzzle!';
                // Optionally disable clicks or show a celebratory animation
            }
        }

        // --- Event Listeners ---
        shuffleButton.addEventListener('click', shufflePuzzle);
        resetButton.addEventListener('click', initializePuzzle); // Reset to solved state

        // --- Initial Setup on Window Load ---
        window.onload = () => {
            initializePuzzle();
            // Add a resize listener to ensure background-size is correct if board resizes
            window.addEventListener('resize', () => {
                // Re-calculate board size and re-render on resize
                const boardSize = puzzleBoard.offsetWidth;
                puzzleBoard.style.setProperty('--grid-size-px', `${boardSize}px`);
                renderPuzzle();
            });
        };
    </script>
</body>
</html>

