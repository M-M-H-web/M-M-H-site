<!DOCTYPE html>
<html>
<head>
    <title>Potato Farm Puzzle</title>
    <style>
        body {
            <div style="text-align: center; margin: 20px;">
  <img 
    src="poisonous-pomato-berry.jpg" 
    alt="Poisonous pomato berry" 
    style="max-width: 100%; height: auto; border-radius: 8px;"
  >
  <p><em>A mysterious pomato berry!</em></p>
</div>
            font-family: Arial, sans-serif;
            text-align: center;
            background: #e6f7e6;
            padding: 20px;
        }
        h1 {
            color: #8b4513;
            margin-bottom: 10px;
        }
        #puzzle-container {
            width: 400px;
            height: 400px;
            margin: 20px auto;
            position: relative;
            border: 3px solid #8b4513;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .puzzle-tile {
            position: absolute;
            width: 100px;
            height: 100px;
            background-size: 400px 400px;
            border: 1px solid #ddd;
            transition: all 0.2s;
            cursor: pointer;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        .puzzle-tile:hover {
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        #controls {
            margin: 20px;
        }
        button {
            background: #8b4513;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #a0522d;
        }
        #moves {
            font-size: 18px;
            margin: 10px;
            font-weight: bold;
        }
        #win-message {
            font-size: 24px;
            color: #8b4513;
            font-weight: bold;
            margin: 20px;
            height: 30px;
        }
    </style>
</head>
<body>
    <h1>Potato Farm Puzzle</h1>
    <p>Rearrange the tiles to complete the picture!</p>
    
    <div id="moves">Moves: 0</div>
    <div id="win-message"></div>
    
    <div id="puzzle-container"></div>
    
    <div id="controls">
        <button id="shuffle-btn">Shuffle</button>
        <button id="new-image-btn">New Image</button>
    </div>

    <script>
        // Game variables
        const puzzleContainer = document.getElementById('puzzle-container');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const newImageBtn = document.getElementById('new-image-btn');
        const movesDisplay = document.getElementById('moves');
        const winMessage = document.getElementById('win-message');
        
        let tiles = [];
        let emptyPos = {row: 3, col: 3};
        let moves = 0;
        let gameStarted = false;
        
        // Potato farm image (can be changed)
        let currentImage = 'https://i.imgur.com/JnJtZP5.jpg';
        
        // Initialize the game
        function initGame() {
            puzzleContainer.innerHTML = '';
            tiles = [];
            moves = 0;
            movesDisplay.textContent = 'Moves: 0';
            winMessage.textContent = '';
            gameStarted = false;
            
            // Create tiles
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    // Skip the bottom-right tile (empty space)
                    if (row === 3 && col === 3) continue;
                    
                    const tile = document.createElement('div');
                    tile.className = 'puzzle-tile';
                    tile.style.backgroundImage = `url(${currentImage})`;
                    tile.style.backgroundPosition = `-${col * 100}px -${row * 100}px`;
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    tile.dataset.correctRow = row;
                    tile.dataset.correctCol = col;
                    
                    tile.textContent = (row * 4 + col + 1).toString();
                    
                    tile.addEventListener('click', () => moveTile(tile));
                    
                    puzzleContainer.appendChild(tile);
                    tiles.push(tile);
                    
                    // Position the tile
                    updateTilePosition(tile, row, col);
                }
            }
        }
        
        // Update tile position on screen
        function updateTilePosition(tile, row, col) {
            tile.style.left = `${col * 100}px`;
            tile.style.top = `${row * 100}px`;
            tile.dataset.row = row;
            tile.dataset.col = col;
        }
        
        // Move a tile if possible
        function moveTile(tile) {
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);
            
            // Check if tile is adjacent to empty space
            if ((Math.abs(row - emptyPos.row) === 1 && col === emptyPos.col) ||
                (Math.abs(col - emptyPos.col) === 1 && row === emptyPos.row)) {
                
                if (!gameStarted) gameStarted = true;
                
                // Swap positions
                updateTilePosition(tile, emptyPos.row, emptyPos.col);
                emptyPos = {row: row, col: col};
                
                // Update moves
                moves++;
                movesDisplay.textContent = `Moves: ${moves}`;
                
                // Check if puzzle is solved
                if (checkWin()) {
                    winMessage.textContent = `You won in ${moves} moves!`;
                }
            }
        }
        
        // Check if puzzle is solved
        function checkWin() {
            for (const tile of tiles) {
                if (parseInt(tile.dataset.row) !== parseInt(tile.dataset.correctRow) || 
                    parseInt(tile.dataset.col) !== parseInt(tile.dataset.correctCol)) {
                    return false;
                }
            }
            return true;
        }
        
        // Shuffle the tiles
        function shuffleTiles() {
            if (gameStarted) return;
            
            // Fisher-Yates shuffle algorithm
            const positions = [];
            for (let i = 0; i < 15; i++) {
                positions.push(i);
            }
            
            // Shuffle the positions
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }
            
            // Update tile positions
            emptyPos = {row: 3, col: 3};
            let index = 0;
            
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    if (row === 3 && col === 3) continue;
                    
                    const pos = positions[index];
                    const tileRow = Math.floor(pos / 4);
                    const tileCol = pos % 4;
                    
                    updateTilePosition(tiles[index], tileRow, tileCol);
                    index++;
                }
            }
            
            // Make sure the puzzle is solvable
            if (!isSolvable(positions)) {
                // If not solvable, swap first two tiles
                [positions[0], positions[1]] = [positions[1], positions[0]];
                shuffleTiles(); // Recursively shuffle again
            }
        }
        
        // Check if the puzzle is solvable
        function isSolvable(positions) {
            let inversions = 0;
            for (let i = 0; i < positions.length; i++) {
                for (let j = i + 1; j < positions.length; j++) {
                    if (positions[i] > positions[j]) {
                        inversions++;
                    }
                }
            }
            // For 4x4 puzzle, solvable if:
            // (inversions is even and empty row is odd) or (inversions is odd and empty row is even)
            return (inversions % 2 === 0) === (emptyPos.row % 2 === 1);
        }
        
        // Change the puzzle image
        function changeImage() {
            const images = [
                'https://i.imgur.com/JnJtZP5.jpg', // Russet potato
                'https://i.imgur.com/5bGJVZ3.jpg', // Red potato
                'https://i.imgur.com/8zUv9mY.jpg', // Sweet potato
                'https://i.imgur.com/3qYQZ7j.jpg'  // Fingerling potato
            ];
            
            currentImage = images[Math.floor(Math.random() * images.length)];
            initGame();
        }
        
        // Event listeners
        shuffleBtn.addEventListener('click', () => {
            if (!gameStarted) {
                shuffleTiles();
            }
        });
        
        newImageBtn.addEventListener('click', changeImage);
        
        // Start the game
        initGame();
    </script>
</body>
</html>
```
